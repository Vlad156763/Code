#include "Data_structures.h"
using namespace data_struct;
using std::cout;
using std::endl;
using std::cin;
/*
Двозв'язний список
додавання вузла в початок списку,
додавання вузла,
пошук вузла в списку,
видалення вузла,
виведення вузлів на екран з початку та з кінця.
*/




/*
Купа(черга з пріорітетами)
Правила побудови купи:
має пірамідальну форму
кожен вузол має три родича: Батька і двох дітей. (корінь не має батька, останні вузли мають дітей опціонально)
Якщо купа максимальна то найбільший елемент буде зверху купи, відповідно значення будуть йти від найбільшого (кореня) до останніх рядів.
індексація відбувається наступинм чином:

	   [0]
	 /     \
  [1]      [2]
 /   \    /   \
[3]  [4] [5]  [6]
і так далі.

В порівнянні з масивом, доступ до елементу є тільки для кореня.
для інших елементів доступу немає доти, доки цей елемент не стане коренем.


(*1)
			  100
		   /      \
	     90       40
       /   \     /   \
	 10    20   9     7
   /   \
 10	   19




От наприклад: Є задача, повернути елемент з індексом [1] з купи: (*1)
цього не може відбутись, так як [1] це не корінь, тому метод повинен кинути вийняток.

Якщо є задача повернути [0] алгоритм такий:
Записую [0] в тимчасову змінну.
видаляю його із купи:
			   - 
		   /      \
		 90       40
	   /   \     /   \
	 10    20   9     7
   /   \
 10	   19
Підставляю останній елемент в корінь: (19 це останній елемент за правилами купи.)
			  19
		   /      \
		 90       40
	   /   \     /   \
	 10    20   9     7
   /  
 10	   
 Перевіряю, чи 19 >= своїм дітям:
 19 >= 90 false
 19 >= 40 false
З першого false зрозуміло що елемент не стоїть на своєму місці, тому порівнюю:
90 та 40 відповідно 90 > 40 тому:
змінюю 19 та 90 місцями:
			  90
		   /      \
		 19       40
	   /   \     /   \
	 10    20   9     7
   /
 10
 Перевіряю, чи 19 >= своїм дітям:
 19 >= 10 true
 19 >= 20 false
 Одна дитина має більше значення, тому порівнювати 20 з 10 немає сенсу
 одразу змінюю 19 та 20 місцями
			  90
		   /      \
		 20       40
	   /   \     /   \
	 10    19   9     7
   /
 10

 Якщо потрібно видалити елемент з індексом [1]
			  100
		   /      \
		 -       40
	   /   \     /   \
	 10    20   9     7
   /   \
 10	   19
 на це місце підставляється останній елемент:
			  100
		   /      \
		 19       40
	   /   \     /   \
	 10    20   9     7
   /   
 10	   
 19 >= 10 true
 19 >= 20 false
 так як тільки 20 false змінюю місцями 19 та 20:
			  100
		   /      \
		 20       40
	   /   \     /   \
	 10    19   9     7
   /
 10

 Якщо треба додати елемент:
			  100
		   /      \
		 90       40
	   /   \     /   \
	 10    20   9     7
   /   \
 10	   19
 Наприклад 1, записуємо його в кінець:
			  100
		   /      \
		 90       40
	   /   \     /   \
	 10    20   9     7
   /   \   /
 10	   19  1
 На даний момент 1 відповідає правилам купи, тому тут все окей.
 Для наглядності додам число 55:
			  100
		   /      \
		 90       40
	   /   \     /   \
	 10    20   9     7
   /   \   /
 10	   19  55
 перевірка:
55 >= 20 брехня, тому змінюю місцями 55 та 20
			  100
		   /      \
		 90       40
	   /   \     /   \
	 10    55   9     7
   /   \   /
 10	   19  20


вставлення елементу,
сортування елементів,


побудова купи з невпорядкованого масиву,

видалення елементу, 
сортування елементів із використанням купи,
виведення елементів на екран.
*/

/*
Пірамідальне сортування
*/

/*
Варіант No 3
Інформація про студентів групи включає наступну інформацію:
– прізвище, ім’я, по батькові;
– адреса;
– середній бал;
– стать;
– дата народження.
Вивести перелік місяців, відсортований за кількістю студентів
групи, які народилися в даний місяць. У випадку однакової кількості
за абеткою.
*/

//Масиви данних зберігаються у файлах


int main() {

	return 0;
}

